package coroutines

import kotlinx.coroutines.*

/**
 * Контекст корутины включает себя такой элемент как диспетчер корутины. Диспетчер корутины
 * определяет какой поток или какие потоки будут использоваться для выполнения корутины.
 *
 * Рассмотрим доступные типы диспетчеров:
 *
 * Dispatchers. Default: применяется по умолчанию, если тип диспетчера не указан явным
 * образом. Этот тип использует общий пул разделяемых фоновых потоков и подходит для вычислений,
 * которые не работают с операциями ввода-вывода (операциями с файлами, базами данных, сетью) и
 * которые требуют интенсивного потребления ресурсов центрального процессора.
 *
 * Dispatchers.IO: использует общий пул потоков, создаваемых по мере необходимости, и
 * предназначен для выполнения операций ввода-вывода (например, операции с файлами или сетевыми запросами).
 *
 * Dispatchers. Main: применяется в графических приложениях, например, в приложениях Android или JavaFX.
 *
 * Dispatchers. Unconfined: корутина не закреплена четко за определенным потоком или пулом потоков.
 * Она запускается в текущем потоке до первой приостановки. После возобновления работы корутина
 * продолжает работу в одном из потоков, который строго не фиксирован. Разработчики языка Kotlin
 * в обычной ситуации не рекомендуют использовать данный тип.
 *
 * newSingleThreadContext и newFixedThreadPoolContext: позволяют вручную задать поток/пул для выполнения корутины
 *
 * newFixedThreadPoolContext — это функция в Kotlin Coroutines, которая позволяет создавать новый контекст
 * корутин с фиксированным пулом потоков. Этот контекст может быть полезен для выполнения задач, которые
 * требуют фиксированного количества потоков, например, когда нужно ограничить количество параллельно выполняющихся задач.
 */
@OptIn(ExperimentalCoroutinesApi::class, DelicateCoroutinesApi::class)
suspend fun main() {
    coroutineScope {
        //Для начала хотел продемонстрировать как можно узнать на каком потоке выполняется программа и как перейти на другой.
        println("Мы в потоке ${Thread.currentThread().name}")
        withContext(Dispatchers.IO) {//Функция withContext в Kotlin используется для изменения контекста выполнения корутины.
            println("Мы в потоке ${Thread.currentThread().name}")
        }
        println()

        withContext(Dispatchers.Unconfined) {//В консольных приложениях Dispatchers. Main недоступен по умолчанию, и попытка использовать его приводит к этой ошибке.
            println("Мы в потоке ${Thread.currentThread().name}")
            delay(300L)
            println("После приостановки мы в потоке ${Thread.currentThread().name}")
        }
        println()

        launch(Dispatchers.Default) { //Явным образом определяем диспетчер Default
            println("Thread is ${Thread.currentThread().name}")
        }
        println()

        launch(newSingleThreadContext("MyThread")) {
            println("Мы уже в потоке ${Thread.currentThread().name}")
        }
        println()

        async(newFixedThreadPoolContext(2, "NewThread")) {
            println("Мы уже в потоке ${Thread.currentThread().name}")
        }.await()
    }
}