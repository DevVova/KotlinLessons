package oopplus

/**
 * Нередко может возникать задача по преобразованию типов, например, чтобы использовать
 * данные одного типа в контексте, где требуются данные другого типа.
 * Для преобразования данных одного типа в другой можно использовать встроенные следующие
 * функции, которые есть у базовых типов (Int, Long, Double и т.д.).
 * Однако надо учитывать, что значение не всегда может быть преобразовано к определенному
 * типу. И в этом случае генерируется исключение. Соответственно в таких случаях желательно
 * отлавливать исключение.
 */

fun main() {
    var stepsString = "not value"
    print("Введите количество совершённых шагов: ")
    try {
        stepsString = readln()
        val steps = stepsString.toInt()
        val result = countingCalories(steps)
        println("Вы сожгли $result калорий.")
    } catch (e: Exception) {
        if (stepsString.isEmpty()) println("Вы ничего не ввели... Попробуйте ещё.") else
            println("Вы ввели число не цифрами... Вы ввели количество словом \"$stepsString\". Попробуйте ещё.")
        e.message
    } finally {
        println("Расчёт сожжённых калорий завершён.")
    }
    println()

    //Smart cast и оператор is.
    val bob = Human(21)
    val ted = Man(45, "Ted")
    info(bob)
    println()
    info(ted)
    println("\n")

    //as
    infoWithAs(bob)
    infoWithAs(ted)
}

//Пример функции, рассчитывающей калории.
fun countingCalories(steps: Int): Int {
    return steps * 20
}

open class Human(val age: Int)

class Man(age: Int, val name: String) : Human(age)

/**
 * Оператор is позволяет проверить выражение на принадлежность определенному типу данных.
 * Этот оператор возвращает true, если значение слева от оператора принадлежит типу,
 * указанному справа от оператора.
 * Данные преобразования еще называются smart casts или "умные преобразования".
 *
 * Также можно применять другую форму оператора - !is. Она возвращает true, если
 * значение НЕ представляет указанный тип данных.
 *
 * Нужно быть осторожным, так как для умного преобразования существуют ограничения.
 * Чтобы не заморачиваться, лучше использовать их только для val значений и избегать var.
 */
fun info(human: Human) {
    if (human is Man) println("Это мужчина. Его зовут ${human.name}.")
    else println("Это человек.")
    if (human !is Man) println("Он просто человек.")
}

//Явные преобразования и оператор as.
//С помощью оператора as мы можем приводить значения одного типа к другому типу.
//Только нужно быть осторожным и проверять на null если что.
fun infoWithAs(human: Human) {
    val man = human as? Human
    println("Теперь он стал человеком, а до этого был мужчиной. И ему ${man?.age} лет.")
}