package async

import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.launch

/**
 * Flow в Kotlin позволяет выполнять асинхронные задачи, но он не создает отдельные
 * потоки в традиционном понимании, как Thread. Вместо этого Flow работает с корутинами,
 * которые обеспечивают асинхронность и могут выполняться в одном или нескольких потоках.
 * Это позволяет организовать асинхронные потоки данных без создания множества потоков,
 * эффективно управляя ресурсами и избегая блокировки.
 *
 * Что делает Flow асинхронным?
 * Flow позволяет выдавать (эмитировать) элементы по мере их готовности, и эти элементы
 * могут асинхронно обрабатываться на стороне подписчика (того, кто вызывает collect).
 * Важно понимать, что Flow не создает отдельные потоки автоматически, а скорее позволяет
 * управлять асинхронной обработкой данных с помощью корутин и диспетчеров потоков (Dispatchers).
 */
suspend fun main(): Unit = coroutineScope {
    val listQuotes: List<Quotes> = listOf(
        Quotes(12, 2.4),
        Quotes(13, 2.7),
        Quotes(14, 2.9),
        Quotes(15, 2.5),
        Quotes(16, 2.1)
    )
    /**
     * Для управления объектами из потока для интерфейса Flow определен ряд функций,
     * одной из которых является функция collect(). В качестве параметра она принимает
     * функцию, в которую передает эмитируемый объект из потока. Так, в данном случае
     * это просто функция вывода на консоль:
     */
    getQuotes(listQuotes).collect { print("$it  ") }
    println()

    //А вот реальный пример, когда мы полученные данные из потока сохраняем в другой список.
    val someQuotes = mutableListOf<Quotes>()
    launch {
        getQuotes(listQuotes).collect { someQuotes.add(it) }
        for (i in someQuotes) {
            delay(200)
            print("$i, ")
        }
        println()
    }
    launch {
        /**
         * Стоит отметить, что асинхронный поток не запускается, пока не будет применена
         * терминальная операция над получаемыми данными, например, функция collect():
         */
        val quotesFlow = getQuotes(listQuotes)//Поток создан, но не запущен.
        quotesFlow.collect { print("$it * ") }//А вот сейчас поток запущен.
        println()
    }
    //Ниже это для примера как запускать ещё параллельно другие корутины.
    launch { println("Hello!") }
}

data class Quotes(val time: Long, val price: Double)

/**
 * Для создания асинхронного потока данных применяется интерфейс Flow. То есть по сути
 * асинхронный поток - это объект Flow. Он типизируется типом тех данных, которые должны
 * передаваться в потоке.
 *
 * Для создания объекта Flow применяется специальная функция flow().
 */
fun getQuotes(list: List<Quotes>): Flow<Quotes> = flow {
    for (i in list) {
        delay(500L)
        emit(i)//Эмитируем(выпускаем) значение.
    }
}